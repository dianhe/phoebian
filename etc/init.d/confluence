#! /bin/bash

### BEGIN INIT INFO
# Provides:        confluence
# Required-Start:    $remote_fs $network $ssh $remote_fs
# Required-Stop:    $remote_fs $network $ssh $remote_fs
# Default-Start:    2 3 4 5
# Default-Stop:        0 1 6
# Short-Description:    Confluence
### END INIT INFO

#    JAVA_OPTS="$JAVA_OPTS -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8086 -Dcom.sun.management.jmxremote.authenticate=false"
#    JAVA_OPTS="$JAVA_OPTS -Xloggc:/var/local/confluence/logs/$GC_LOG -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+HeapDumpOnOutOfMemoryError"
#    JAVA_OPTS="$JAVA_OPTS -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=1101"
NAME=confluence
STAMP=`date -u +"%Y%m%d-%H%M%S"`

set -e

if [ -f "/lib/lsb/init-functions" ]; then
    . /lib/lsb/init-functions
else # this is for OS X where we do not have them, copy the jira to ~/bin and be sure this is part of your PATH
    shopt -s expand_aliases
    alias log_action_msg=echo
    alias log_daemon_msg=echo
    alias log_progress_msg=echo
    alias log_end_msg=echo
fi

#JAVA_OPTS="$JAVA_OPTS -XX:OnOutOfMemoryError=\"kill -9 %p\" "
# NOTE: Do not rely on any previously configured JAVA_OPTS.
export JAVA_OPTS=""
start_time=`date +%s`

function moveallto() {
    local DESTDIR=${1}
    mkdir -p ${DESTDIR}
    find -maxdepth 1 -type f -not -name ${DESTDIR} -not -path "./${DESTDIR}/*" -exec mv '{}' "${DESTDIR}/{}" \;
}


TIMEOUT=30
OUTPUT=$(mktemp)
# number of seconds to wait before forcing a stop command

# set -e

# detect java location
if [ "$JAVA_HOME" = "" ]; then
    for JAVA_HOME in /usr/lib/jvm/java-7-oracle /usr/lib/jvm/java-6-oracle /usr/lib/jvm/java-6-sun /usr/lib/jvm/default-java /System/Library/Frameworks/JavaVM.framework/Home/ /opt/Confluence/jre
    do
        if [ -d "$JAVA_HOME" ]; then break ; fi
    done
fi
export JAVA_HOME

if [ "${JAVA_HOME}" = "" ] ; then
  echo "Failed to detect JAVA_HOME location, we cannot proceed."
  exit 1
fi

# detect product location 
# list of possible locations of confluence, newer versions do have priority, if you have another location just overwrite this or make a symlink 
for ROOT_DIR in /opt/Confluence/bin ~/opt/confluence/bin /opt/$NAME/bin /opt/atlassian/confluence/bin
do
    if [ -d "$ROOT_DIR" ]; then break ; fi
done
if [[ ! -e "$ROOT_DIR/startup.sh" ]] ; then
  echo "FATAL: Unable to detect confluence install directory."
  exit 1
fi

for CONFLUENCE_HOME in /var/atlassian/application-data/confluence /var/local/confluence ~/dev/data/confluence /var/atlassian/application-data/confluence
do
    if [ -d "$CONFLUENCE_HOME" ]; then break ; fi
done
if [[ ! -f "$CONFLUENCE_HOME/confluence.cfg.xml" ]] ; then 
   echo "FATAL: Unable to detect confluence home directory."
   exit 1
fi


#test -x "${ROOT_DIR}/startup.sh" || ((echo "unable to find confluence startup.sh" && exit 1))
#test -x "${ROOT_DIR}/shutdown.sh" || ((echo "unable to find confluence shutdownp.sh" && exit 1))

# read the address where the service is supposed to respond
PROXYNAME=`cat "${ROOT_DIR}/../conf/server.xml" | sed -ne 's/.*proxyName="\([^"]*\)".*/\1/p' | head -n 1`
SCHEME=`cat "${ROOT_DIR}/../conf/server.xml" | sed -ne 's/.*scheme=\"\([^"]*\)\".*/\1/p' | head -n 1`
PORT=`cat "${ROOT_DIR}/../conf/server.xml" | sed -ne 's/.*<Connector.*port="\([^"]*\)".*/\1/p' | head -n 1`
PROXYPORT=`cat "${ROOT_DIR}/../conf/server.xml" | sed -ne 's/.*proxyPort="\([^"]*\)".*/\1/p' | head -n 1`

if [[ -z "$PROXYNAME" ]] ; then PROXYNAME=localhost ; fi
if [[ -z "$SCHEME" ]] ; then SCHEME=http ; fi
if [[ -z "$PROXYPORT" ]] ; then PROXYPORT=80 ; fi

URL=${SCHEME}://${PROXYNAME}:${PROXYPORT}

# creating the output file
echo "Supposed to run on port $PORT and be accesible using $URL" >${OUTPUT}

if test -f /etc/default/$NAME; then
    . /etc/default/$NAME
fi


mkdir -p ${CONFLUENCE_HOME}/logs

function get_PID() {
    PID=`ps -A -o pid,command|grep java|grep "$ROOT_DIR"|awk '{print $1}'`
}


clean_exit() {
  zero=0
  if [ $1 -ne $zero ]; then
    # we display the output only in case of error
    cat ${OUTPUT}
  fi
  rm -f ${OUTPUT}
  exit $1
}

function exit_if_maintenance() {
  if [ -f "${ROOT_DIR}/../.maintenance" ]; then
    log_progress_msg "Doing nothing as the systems seems to be in maintenance mode."
    log_end_msg 1
    return 1
  fi
  return 0
}

function enable_maintenance() {
  touch "${ROOT_DIR}/../.maintenance"
  if [ "$PROXYNAME" != "localhost" ] ; then
    log_progress_msg " (enable maintenance mode for $URL) "
    ssh -q -a -t $PROXYNAME -o BatchMode=yes -o StrictHostKeyChecking=no -f "ln -s -f /etc/nginx/www/maintenance.html /etc/nginx/www/$PROXYNAME-maintenance.html || hostname" || echo "maint-failed"
  fi
}

function disable_maintenance() {
  if [ -f "${ROOT_DIR}/../.maintenance" ]; then
    rm -f "${ROOT_DIR}/../.maintenance"

    if [ "$PROXYNAME" != "localhost" ] ; then
      log_progress_msg " (disable maintenance mode for $URL) "
    fi
    if tty -s; then
        # do_interactive_stuff
        ( tail -q -F /var/local/confluence/logs/atlassian-confluence.log -F "$ROOT_DIR/../logs/catalina.out" 2>/dev/null & ( (tail -q -F /var/local/confluence/logs/atlassian-confluence.log -F "$ROOT_DIR/../logs/catalina.out" 2>/dev/null | grep -l 'INFO: Server startup in' && kill -9 `pstree -pa $$ | grep -E '\-(tail|sleep),' | sed 's/^[^0-9]*\([0-9]*\).*/\1/' | grep -vw $$ | xargs` >/dev/null 2>&1 ) & sleep 900 && kill -9 `pstree -pa $$ | grep -E '\-(tail|sleep),' | sed 's/^[^0-9]*\([0-9]*\).*/\1/' | grep -vw $$ | xargs` >/dev/null 2>&1 && exit 3 ) ) ; [ $? -eq 3 ]  && echo 'server not up after 5 min'  || echo 'server up'
    fi
    if [ "$PROXYNAME" != "localhost" ] ; then
      ssh -q -a -t $PROXYNAME -o BatchMode=yes -o StrictHostKeyChecking=no -f "rm -f /etc/nginx/www/$PROXYNAME-maintenance.html "
    fi
  fi

}

function thread_dump() {
  get_PID
  count=5
  delay=0.5
  echo "Taking ${count} thread dumps for PID=$PID with ${delay} seconds inbetween..."

  while [ $count -gt 0 ]
  do
    #jstack -l $pid >jstack.$pid.$(date +%H%M%S.%N)
    
    DUMP="${ROOT_DIR}/../logs/threaddump.$PID.$(date +%H%M%S.%N).txt"
    echo "---" >> ${DUMP}
    jstack -l $PID >> ${DUMP}
    sleep $delay
    let count--
    echo -n "."
  done

  
}

function wait_to_end() {
            get_PID
            #echo PID=${PID}
            t=$TIMEOUT
            while [ "$t" -gt "0" ] && [ -n "$PID" ]; do
                echo -n "."
                sleep 1
                get_PID
                t=$(( t - 1 ))
            done
            get_PID
}


function daemon_start() {
        # rotating the logs, so we get an empty set for each restart
        pushd $(pwd) >> /dev/null
        cd $ROOT_DIR/../logs
        moveallto $STAMP
        popd >> /dev/null

        # see https://confluence.atlassian.com/display/GHKB/Upon+Upgrade+to+GreenHopper+6.0.1+the+Agile+Menu+Generates+an+Error
        rm -rf $ROOT_DIR/../work/*

        # rotating the logs, so we get an empty set for each restart
        pushd $(pwd) >> /dev/null
        cd $CONFLUENCE_HOME/logs
        moveallto $STAMP
        popd >> /dev/null

        rm -rf $CONFLUENCE_HOME/plugins-osgi-cache/*
        rm -rf $CONFLUENCE_HOME/bundled-plugins/*
        rm -rf $CONFLUENCE_HOME/plugins-temp/*
        rm -rf $CONFLUENCE_HOME/plugins-cache/*

        #if "${ROOT_DIR}/startup.sh" 2>&1 >>${OUTPUT} ; then
        if "${ROOT_DIR}/startup.sh" ; then

            log_end_msg 0
        else
            log_end_msg 1
        fi
}

function daemon_stop() {
    "${ROOT_DIR}/shutdown.sh" >>${OUTPUT} 2>&1 || true
    wait_to_end
        if [ -n "$PID" ]; then
            log_progress_msg " forcing "
            thread_dump
            "${ROOT_DIR}/shutdown.sh" -force >>${OUTPUT} 2>&1 || true
            wait_to_end
            if [ -n "$PID" ]; then
                    thread_dump
                    log_progress_msg " killing $PID "
                    kill -9 $PID
                    wait_to_end
            fi
        fi
}

case "$1" in
  start)
    log_daemon_msg "Starting $NAME instance" "$NAME"
    daemon_start
    disable_maintenance
    ;;
  stop)
    log_daemon_msg "Stopping $NAME instance" "$NAME"
    
    enable_maintenance
    daemon_stop
    log_end_msg 0
    ;;
  dump)
    log_daemon_msg "Thread dumping $NAME instance" "$NAME"
    thread_dump $PID
    ;;
  status)
    get_PID
    log_daemon_msg "$NAME instance PID=$PID" "$NAME"
    echo .
    ;;

  restart)
    log_daemon_msg "Restarting $NAME instance" "$NAME"

    # if someone stopped service on purpose (with stop) we will not start it with restart as we consider to be in maintenance mode.
    # This allows us to restart service using nagios when it stops responding, as long it wasn't stopped on purpose.
    exit_if_maintenance
    if [ $? == 0 ] ; then
        daemon_stop
        daemon_start
        echo "run time is $(expr `date +%s` - $start_time)s ... stil it could take few minutes until the service is fully up."
    else
        echo "maintenance detected canceling..."
        clean_exit 1
    fi
    ;;
  *)
    log_action_msg "Usage: /etc/init.d/$NAME {start|stop|restart|status|dump}" || true
    clean_exit 1
    ;;
esac

clean_exit 0
